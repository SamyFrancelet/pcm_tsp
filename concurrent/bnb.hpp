#include "path.hpp"
#include "matrix.hpp"
#include <iostream>

#ifndef BNB_HPP
#define BNB_HPP

// Branch and bound algorithm
class BnB {
public:
    explicit BnB(EdgeMatrix edges) {
        _leftMatrix = edges;
        _rightMatrix = edges;
        generate_childs();
    }

    EdgeMatrix left() const { return _leftMatrix; }
    EdgeMatrix right() const { return _rightMatrix; }

private:
    /**
     * Generate the childs of the current path.
     * The left child is generated by including the next unused edge to the path.
     * The right child is generated by excluding the next unused edge from the path.
     * 
     * When a child is generated, we must check the following:
     * 1. If excluding edge(i, j) from the path make it impossible
     *    for node i or j to have as many as two edges in the path,
     *    then edge(i, j) must be included in the path.
     * 2. If including edge(i, j) would cause node i or j to have
     *    more than two edges in the path, then edge(i, j) must be excluded.
     * 3. If including edge(i, j) would cause the path to have a
     *    partial cycle, then edge(i, j) must be excluded.
     * 
     * Reminder: 0 = unused, 1 = included, -1 = excluded
    */
    void generate_childs() {
        // Find the next unused edge
        int i = 0;
        int j = 0;
        bool found = false;
        for (i = 0; i < _leftMatrix.size(); i++) {
            for (j = 0; j < _leftMatrix.size(); j++) {
                if (_leftMatrix[i][j] == 0 && i != j) {
                    found = true;
                    break;
                }
            }
            if (found) {
                break;
            }
        }

        if (!found) {
            return;
        }

        // Include the next unused edge in the left child
        _leftMatrix[i][j] = 1;
        _leftMatrix[j][i] = 1;
        update_child(_leftMatrix);

        // Exclude the next unused edge in the right child
        _rightMatrix[i][j] = -1;
        _rightMatrix[j][i] = -1;
        update_child(_rightMatrix);
    }

    void update_child(EdgeMatrix &child) {
        // Compute the number of used edges for each node
        // and the number of unused edges for each node
        std::vector<int> usedEdges(child.size(), 0);
        std::vector<int> unusedEdges(child.size(), 0);

        for (int i = 0; i < child.size(); i++) {
            for (int j = i+1; j < child.size(); j++) {
                if (child[i][j] == 1) {
                    usedEdges[i]++;
                    usedEdges[j]++;
                } else if (child[i][j] == 0) {
                    unusedEdges[i]++;
                    unusedEdges[j]++;
                }
            }
        }

        // If node i has 1 used edge and 1 unused edge,
        // or 0 used edge and 2 unused edges,
        // then the unused edge must be included in the path.
        // If node i has 2 used egdes, then the unused edges must be excluded.
        for (int i = 0; i < child.size(); i++) {
            if ((usedEdges[i] == 1 && unusedEdges[i] == 1) ||
                (usedEdges[i] == 0 && unusedEdges[i] == 2)) {
                for (int j = i+1; j < child.size(); j++) {
                    if (child[i][j] == 0 && i != j && unusedEdges[j] >= 1 && usedEdges[j] <= 1) {
                        child[i][j] = 1;
                        child[j][i] = 1;
                        break;
                    }
                }
            }

            if (usedEdges[i] == 2) {
                for (int j = i+1; j < child.size(); j++) {
                    if (child[i][j] == 0 && i != j) {
                        child[i][j] = -1;
                        child[j][i] = -1;
                    }
                }
            }
        }

    }

    EdgeMatrix _leftMatrix;
    EdgeMatrix _rightMatrix;
};

#endif // BNB_HPP